{
  "rules": [
    {
      "type": "prd",
      "content": "# BuddyBudget — PRD v1.0 (MVP)\n\n## 1. 제품 한 줄 요약\n공동 생활자·가족이 한눈에 자산·지출·예산을 관리할 수 있는 초간편 웹 머니 트래킹 툴.\n\n## 2. 배경 & 기회\n• 대한민국 1~2인 가구, 쉐어하우스·신혼부부 증가로 ‘공동 지출 관리’ 수요 확대.\n• 현재 해결책은 엑셀·메신저 기반 수작업 → 번거롭고 실수 많음.\n• 모바일·웹 기반 간편 툴로 전환 시 TTV(Time-To-Value) 대폭 단축 가능.\n\n## 3. 목표\n1. 공동 지출 입력 시간을 1건당 30초 이내로 단축.\n2. 신규 사용자가 첫 거래 입력까지 3분 이내 달성(TTV).\n3. 초대 수락 전환율 ≥ 70 %.\n\n## 4. 주요 타깃\n| 페르소나 | 특징 | 주요 Pain Point |\n|-----------|------|----------------|\n| 20‧30대 룸메이트 | 2~4명, 월세·공과금·식비 공유 | 수작업 정산·송금 번거로움 |\n| 신혼/동거 부부   | 공동 통장·카드 사용 | 월 예산 초과 여부가 불투명 |\n| 3~4인 가족       | 가족 카드·현금 혼용 | 잔액·카테고리별 사용 내역 불명확 |\n\n## 5. 핵심 Use Case (우선순위순)\n1. 월세·공과금·식비 공동 관리 및 정산\n2. 신혼부부 공동 통장 관리\n3. 가족 공동 카드 지출 내역 정리 및 예산 체크\n\n## 6. 해결할 Pain Point\n1. 엑셀/카톡 정산의 번거로움 → 자동 집계\n2. 예산 초과 여부 불명확 → 실시간 집행률\n3. 공동 계좌 잔액 파악 어려움 → 대시보드 실시간 잔액\n\n## 7. 사용자 목표\n1. 수작업 없이 공동 지출을 쉽게 기록·관리\n2. 공동 계좌 잔액을 실시간 확인\n3. 월 예산을 지키며 과소비 방지\n\n## 8. 비즈니스 모델\nFreemium.\n• 기본: Space 1개 + 멤버 2명 무료.\n• Pro: Space 추가 시 Space당 월 4,900원, 멤버 무제한 + 예산 초과 알림·고급 통계·다크모드 커스텀.\n\n## 9. 개발 전략\nMVP → 빠른 런칭 후 지표·피드백 기반 반복 개선(Agile 2주 스프린트 운영).\n\n## 10. 기능 범위\n### 10.1 MUST (MVP)\n1. Space 생성·관리\n2. 거래(수입·지출·이체) 입력 & 목록 조회\n3. 멤버 초대·가입 관리(Google OAuth)\n4. 예산 설정 & 대시보드 집행률\n5. 카테고리·계정(Holding) CRUD\n6. 기본 통계(월별/카테고리별)\n### 10.2 NICE TO HAVE (MVP 내 포함)\n7. 빠른 거래 입력 위젯(대시보드 상단)\n8. 예산 초과 알림(이메일)\n9. 다크 모드\n### 10.3 LATER(후속)\n– 자동 태그 추천, 거래 CSV 내보내기, 모바일 앱, 은행 자동 연동\n\n## 11. 성공 지표(KPI)\n| 구분 | 지표 | 목표 |\n|------|------|------|\n| Activation | 첫 Space 생성 후 첫 거래 입력까지 소요 시간 | ≤ 3분 |\n| Retention | 주간 활성 Space 비율(최근 7일 내 1건 이상 거래) | ≥ 40 % |\n| Invitation | 초대 링크 → Space 참여 완료 | ≥ 70 % |\n| Monetisation | Pro 전환율(무료→유료 Space) | ≥ 3 % |\n\n## 12. 기술 스택(기본)\nNext.js 15, TypeScript, TailwindCSS, shadcn/ui, lucide-react, @tanstack/react-query, Supabase(PostgreSQL + Auth + Storage), Drizzle ORM, date-fns.\n\n## 13. 핵심 화면 / 사용자 흐름\n1. 로그인(Google) → Space가 없으면 ‘Space 만들기’ 모달\n2. /[slug] 대시보드: 잔액·집행률·최근 거래 + 빠른 입력\n3. 거래 입력: 금액→카테고리→계정 순, ‘이체’ 선택 시 목적지 계정 표시\n4. 예산 설정: 카테고리별 월 한도 입력 → 대시보드 Progress Bar\n5. 멤버 초대: 이메일 입력 → 수락 링크(메일) → 로그인 → Space 참여 완료\n\n## 14. 주요 비기능 요구사항\n• 멀티테넌시 & RLS로 데이터 분리 보안 확보\n• 모바일 반응형(> 375px) 우선\n• 평균 API 응답 300 ms 이내\n• WCAG 2.1 AA 준수(색 대비, 키보드 접근성)\n\n## 15. 리스크 & 대응\n| 리스크 | 영향 | 대응 |\n|---------|------|------|\n| 복잡한 초대/가입 플로우 | Activation 저하 | Google OAuth + 딥링크로 간소화 |\n| 잔액 계산 성능 | 느린 대시보드 로딩 | Materialized View + 5분 단위 Refresh |\n| 결제(Paid Space) 도입 난이도 | BM 지연 | 토스페이먼츠 Billing API 2차 스프린트 반영 |\n\n## 16. 일정(고수준)\n| 스프린트 | 기간 | 목표 |\n|-----------|------|------|\n| 0 | W0 | 요구사항 확정·기술 세팅 |\n| 1 | W1-2 | Space·Auth·DB 스키마·기본 UI |\n| 2 | W3-4 | 거래 CRUD + 대시보드 │\n| 3 | W5-6 | 예산·초대·알림 │\n| 4 | W7 | 유료 결제·다크모드 │\n| 5 | W8 | 버그픽스·런칭 |\n\n## 17. 향후 로드맵(6M)\n1. 모바일 PWA\n2. 은행/카드 자동 연동(Open Banking)\n3. AI 지출 카테고리 추천\n4. 가족·커플용 ‘정산 챗봇’\n\n---\n최종 업데이트: 2025-09-08",
      "writedAt": "2025-09-09T13:44:40.108Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **Project Overview**: 'BuddyBudget'은 공동 생활자를 위한 웹 기반 자산·지출 관리 SaaS입니다. Next.js App Router를 활용한 풀스택 애플리케이션으로 구현하며, 백엔드 인프라는 Supabase의 BaaS(Backend as a Service)를 적극적으로 활용하여 개발 속도와 효율성을 극대화합니다. 멀티테넌시 아키텍처를 기반으로 각 'Space' 단위의 데이터를 PostgreSQL의 RLS(Row-Level Security)를 통해 완벽하게 격리합니다.\n- **Core Technology Stack**: Next.js 15, TypeScript, Supabase(PostgreSQL, Auth, Storage, Edge Functions), Drizzle ORM을 핵심 스택으로 사용합니다. UI는 TailwindCSS, shadcn/ui, lucide-react로 구현하며, 데이터 페칭 및 상태 관리는 @tanstack/react-query를 활용합니다. 이메일 발송은 Resend, 구독 결제는 토스페이먼츠를 연동합니다.\n- **Key Technical Objectives**:\n    - **데이터 격리**: Supabase RLS를 통해 사용자 'Space' 간 데이터 접근을 원천 차단하여 멀티테넌시 보안을 확보합니다.\n    - **성능**: 평균 API 응답 시간을 300ms 이내로 유지하고, 대시보드 로딩 속도를 최적화합니다.\n    - **반응형 UI**: 모바일(최소 375px) 우선 접근 방식으로 모든 디바이스에서 최적의 사용자 경험을 제공합니다.\n    - **접근성**: WCAG 2.1 AA 레벨을 준수하여 색 대비, 키보드 접근성 등을 보장합니다.\n- **Critical Technical Assumptions**:\n    - Supabase의 기본 인프라는 MVP 단계의 트래픽을 충분히 감당할 수 있습니다.\n    - Google OAuth는 MVP의 핵심 인증 방식으로 충분하며, 사용자의 가입 허들을 낮출 수 있습니다.\n    - Resend 및 토스페이먼츠의 API는 안정적이며, 주어진 개발 일정 내에 연동이 가능합니다.\n    - PostgreSQL의 Materialized View 기능으로 대시보드 집계 성능 요구사항을 충족할 수 있습니다.\n\n## 2. Tech Stack\n\n| Category | Technology / Library | Reasoning (Why it's chosen for this project) |\n| --- | --- | --- |\n| **프레임워크** | Next.js 15 | React 서버 컴포넌트(RSC)를 활용한 서버 중심 아키텍처로 초기 로딩 성능을 최적화하고, 단일 코드베이스에서 프론트엔드와 백엔드(API Routes)를 통합 관리하여 개발 생산성을 높입니다. |\n| **언어** | TypeScript | 정적 타입 검사를 통해 코드의 안정성과 유지보수성을 향상시키며, Drizzle ORM과의 연계를 통해 데이터베이스 스키마와 쿼리의 타입 안전성을 보장합니다. |\n| **백엔드 서비스(BaaS)** | Supabase | PostgreSQL 데이터베이스, 인증, 스토리지, 엣지 함수를 통합 제공하여 인프라 구축 시간을 최소화하고 MVP 개발에 집중할 수 있게 합니다. RLS 기능은 멀티테넌시 구현의 핵심입니다. |\n| **데이터베이스 ORM** | Drizzle ORM | TypeScript 기반의 경량 SQL 쿼리 빌더로, 타입 안전성을 극대화하고 SQL에 가까운 직관적인 쿼리 작성이 가능하여 데이터베이스 상호작용의 안정성을 높입니다. |\n| **UI 스타일링** | TailwindCSS | 유틸리티 우선 접근 방식으로 빠르고 일관된 UI 개발을 지원하며, 커스터마이징이 용이하여 프로젝트 고유의 디자인 시스템을 구축하는 데 효율적입니다. |\n| **UI 컴포넌트** | shadcn/ui & lucide-react | 접근성을 준수하는 고품질 UI 컴포넌트 라이브러리로, 개발 속도를 높이고 일관된 디자인을 유지합니다. `lucide-react`는 경량 아이콘을 제공합니다. |\n| **데이터 페칭/상태 관리** | @tanstack/react-query | 서버 상태 관리를 위한 강력한 솔루션으로, 캐싱, 재시도, 데이터 동기화 로직을 자동화하여 API 통신 코드의 복잡성을 줄이고 사용자 경험을 향상시킵니다. |\n| **유틸리티** | date-fns | 경량의 모듈식 날짜/시간 라이브러리로, 필요한 기능만 가져와 사용할 수 있어 번들 크기를 최적화하고 직관적인 API를 제공합니다. |\n| **이메일 서비스** | Resend | 개발자 친화적인 API를 통해 초대 및 알림 등 트랜잭션 이메일을 안정적으로 발송하기 위해 사용합니다. React Email과의 통합이 용이합니다. |\n| **결제 서비스** | TossPayments (Subscription Billing) | 국내 사용자에게 친숙한 결제 경험을 제공하고, 구독 결제(Billing) API를 통해 Pro 플랜의 정기 결제 기능을 안정적으로 구현하기 위해 선택합니다. |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **Next.js Application (Frontend & Backend Logic)**: 사용자와 직접 상호작용하는 웹 애플리케이션입니다. React 서버 컴포넌트(RSC)를 통해 UI를 렌더링하고, 클라이언트 컴포넌트에서 사용자 인터랙션을 처리합니다. API Route Handlers를 사용하여 클라이언트의 요청을 처리하고 비즈니스 로직을 수행합니다.\n    - **Sub-building blocks**: UI Components (shadcn/ui), State Management (@tanstack/react-query), API Route Handlers.\n- **Supabase (BaaS Platform)**: 핵심 백엔드 인프라 역할을 수행합니다. 데이터 저장, 사용자 인증, 서버리스 함수 실행 등 백엔드 기능을 종합적으로 제공하여 개발을 가속화합니다.\n    - **Sub-building blocks**: PostgreSQL Database, Supabase Auth, Supabase Edge Functions, Supabase Storage.\n- **Database (PostgreSQL with Drizzle)**: 애플리케이션의 모든 데이터를 저장하는 영구 저장소입니다. Drizzle ORM을 통해 타입 안전하게 데이터에 접근하며, Supabase RLS 정책으로 데이터 접근 제어를 구현합니다.\n    - **Sub-building blocks**: Drizzle ORM (Query Builder), Database Schema, RLS Policies.\n- **External Services (Third-Party Integrations)**: 애플리케이션의 핵심 기능 외에 필요한 부가 기능을 제공하는 외부 서비스입니다.\n    - **Sub-building blocks**: Resend (Email Notifications), TossPayments (Subscription Billing).\n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n    subgraph Browser\n        User[사용자]\n    end\n\n    subgraph Next.js App\n        Frontend[Next.js Frontend - RSC/Client Components]\n        Backend[Next.js Backend - API Route Handlers]\n    end\n\n    subgraph Supabase\n        Auth[Supabase Auth]\n        DB[(Supabase PostgreSQL<br/>w/ Drizzle ORM & RLS)]\n        Functions[Supabase Edge Functions]\n    end\n\n    subgraph External Services\n        Resend[Resend API]\n        Toss[TossPayments API]\n    end\n\n    User -- interacts --> Frontend\n    Frontend -- API Requests --> Backend\n    Frontend -- Direct Call --> Auth\n    Backend -- DB Queries via Drizzle --> DB\n    Backend -- invoke --> Functions\n    Functions -- calls --> Resend\n    Functions -- calls --> Toss\n```\n\n- **사용자 요청 처리**: 사용자는 브라우저를 통해 Next.js 프론트엔드와 상호작용합니다. 데이터 조회나 변경이 필요할 경우, 클라이언트 컴포넌트는 Next.js 백엔드(API Route Handlers)로 API를 요청합니다.\n- **데이터베이스 상호작용**: Next.js 백엔드는 Drizzle ORM을 사용하여 Supabase PostgreSQL 데이터베이스에 쿼리를 실행합니다. 모든 쿼리는 사용자의 인증 정보에 기반한 RLS 정책에 따라 자동으로 필터링되어 데이터 격리를 보장합니다.\n- **인증 처리**: 로그인, 회원가입 등 인증 관련 요청은 Supabase Auth와 직접 통신하여 처리되며, 발급된 JWT는 후속 API 요청 시 인증 토큰으로 사용됩니다.\n- **외부 서비스 연동**: 이메일 발송, 결제 처리와 같이 보안이 중요하거나 외부와 통신이 필요한 로직은 Supabase Edge Function을 통해 실행하여 안전성과 확장성을 확보합니다.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: `src/domains` 디렉토리 내에 `spaces`, `transactions`, `budgets`, `users` 등 비즈니스 도메인별로 코드를 구성하여 응집도를 높입니다.\n- **Layer-Based Architecture**: 각 도메인 내부는 `actions`(서버 로직), `components`(UI), `lib`(유틸리티), `types` 등으로 계층을 분리하여 관심사를 명확히 합니다.\n- **Feature-Based Modules**: 대시보드, 거래 입력 폼 등 특정 기능을 중심으로 관련된 컴포넌트와 로직을 그룹화합니다.\n- **Shared Components**: 여러 도메인에서 공통으로 사용되는 UI 컴포넌트(`src/components/ui`), 유틸리티 함수(`src/lib`), 타입 정의(`src/types`)는 최상위 디렉토리에 배치하여 재사용성을 극대화합니다.\n\n**Universal File & Folder Structure**\n```\n/\n├── public/                     # 정적 에셋 (이미지, 폰트 등)\n└── src/\n    ├── app/                    # Next.js App Router\n    │   ├── (auth)/             # 인증 관련 페이지 (로그인, 가입)\n    │   ├── (dashboard)/[slug]/ # Space 대시보드 관련 페이지\n    │   │   ├── layout.tsx\n    │   │   └── page.tsx\n    │   ├── api/                # API Route Handlers\n    │   └── layout.tsx          # 루트 레이아웃\n    ├── components/\n    │   ├── common/             # 공통 컴포넌트 (Header, Footer 등)\n    │   └── ui/                 # shadcn/ui 컴포넌트\n    ├── domains/                # 핵심 비즈니스 도메인\n    │   ├── spaces/\n    │   │   ├── actions.ts      # Space 관련 서버 액션/API 로직\n    │   │   ├── components/     # Space 관련 UI 컴포넌트\n    │   │   └── types.ts        # Space 관련 타입 정의\n    │   ├── transactions/\n    │   │   └── ...\n    │   └── users/\n    │       └── ...\n    ├── lib/\n    │   ├── db/                 # Drizzle ORM 설정 및 스키마\n    │   │   └── schema.ts\n    │   ├── supabase/           # Supabase 클라이언트 설정\n    │   └── utils.ts            # 전역 유틸리티 함수\n    └── types/\n        └── index.ts            # 전역 타입 정의\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: 클라이언트는 `@tanstack/react-query`의 `useQuery`와 `useMutation` 훅을 사용하여 Next.js API Route Handlers와 비동기적으로 통신합니다. 서버 액션(Server Actions)을 활용하여 클라이언트 컴포넌트에서 직접 서버 함수를 호출하는 패턴도 적극적으로 사용합니다.\n- **Database Interaction**: 모든 데이터베이스 접근은 Drizzle ORM을 통해 이루어집니다. API Route나 서버 액션 내에서 Drizzle 클라이언트를 사용하여 타입 안전한 쿼리를 실행합니다. 데이터베이스 연결은 Supabase가 관리합니다.\n- **External Service Integration**: 결제 웹훅 처리, 이메일 발송 등 민감하거나 비동기적인 외부 서비스 연동은 Supabase Edge Function을 통해 처리합니다. Next.js 백엔드에서 Edge Function을 `invoke`하는 방식으로 호출합니다.\n- **Real-time Communication**: MVP에서는 실시간 통신이 없으나, 향후 기능 확장 시 Supabase Realtime을 활용하여 대시보드 데이터의 실시간 동기화를 구현할 수 있습니다.\n- **Data Synchronization**: `@tanstack/react-query`의 캐시 무효화(cache invalidation) 전략을 사용하여 데이터 변경(CUD) 후 관련 데이터 조회(R) 쿼리를 자동으로 갱신함으로써 클라이언트와 서버 간의 데이터 정합성을 유지합니다.\n\n## 4. Performance & Optimization Strategy\n\n- **프론트엔드 최적화**: Next.js의 서버 컴포넌트(RSC)를 기본으로 사용하여 서버에서 렌더링을 수행, 클라이언트 JavaScript 번들 크기를 최소화합니다. 정적인 페이지(랜딩페이지 등)는 SSG(Static Site Generation)를 적용하고, `next/image`를 통해 이미지를 최적화합니다.\n- **데이터 페칭 최적화**: `@tanstack/react-query`를 사용하여 API 응답을 클라이언트 측에 캐싱합니다. 동일한 데이터 요청이 반복될 경우 네트워크 요청 없이 캐시된 데이터를 즉시 반환하여 로딩 시간을 단축하고 API 호출 수를 줄입니다.\n- **데이터베이스 성능**: PRD에 명시된 바와 같이, 대시보드의 복잡한 집계 데이터(월별/카테고리별 통계)는 PostgreSQL의 Materialized View를 생성하고 주기적으로(예: 5분마다) 갱신하는 방식으로 처리합니다. 이를 통해 실시간 집계 쿼리로 인한 부하를 방지하고 대시보드 로딩 성능을 보장합니다. `transactions` 테이블의 `space_id`, `created_at` 등 자주 조회되는 컬럼에 인덱스를 생성합니다.\n- **서버리스 아키텍처 활용**: API Route Handlers 및 Supabase Edge Functions는 요청 시에만 실행되는 서버리스 환경에서 동작하므로, 유휴 상태의 리소스 비용이 없고 트래픽에 따라 자동으로 확장되어 효율적인 리소스 관리가 가능합니다.\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation) - Sprint 0 ~ 3 (6주)\n- **Core Infrastructure**: Supabase 프로젝트 설정, PostgreSQL 스키마 정의(Drizzle), Next.js 프로젝트 초기 설정 및 기본 레이아웃 구현. (Sprint 0-1)\n- **Essential Features**: 사용자 인증(Google OAuth), Space 생성/관리, 멤버 초대/참여, 거래(수입/지출/이체) CRUD, 예산 설정, 기본 대시보드(잔액, 집행률) 기능 구현. (Sprint 1-3)\n- **Basic Security**: Supabase RLS 정책을 적용하여 Space 단위 데이터 격리 구현.\n- **Development Setup**: GitHub 레포지토리 설정, Vercel 연동을 통한 기본 CI/CD 파이프라인 구축.\n- **Timeline**: 6주\n\n### Phase 2: Feature Enhancement & Monetization - Sprint 4 ~ 5 (2주)\n- **Advanced Features**: 유료(Pro) 플랜 기능인 예산 초과 알림(Resend 이메일 연동), 다크 모드 구현.\n- **Monetization**: 토스페이먼츠 Billing API를 연동하여 Pro 플랜 구독 결제 기능 구현.\n- **Performance Optimization**: MVP 기능에 대한 성능 테스트 및 Materialized View 등 최적화 전략 적용.\n- **Enhanced Security**: 결제 관련 보안 강화 및 추가적인 RLS 정책 검토.\n- **Monitoring Implementation**: Vercel Analytics 및 기본 로깅을 통한 모니터링 환경 구축.\n- **Timeline**: 2주 (총 8주 후 런칭)\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**:\n    - **리스크**: Supabase RLS 정책의 복잡성. 잘못된 정책 설계 시 데이터 유출 또는 접근 불가 문제 발생 가능.\n    - **Mitigation Strategies**: 개발 초기 단계에 RLS 정책에 대한 철저한 테스트 케이스를 작성하고, 자동화된 테스트를 통해 정책의 정확성을 지속적으로 검증합니다. 동료 코드 리뷰를 통해 정책 로직을 교차 검증합니다.\n- **Performance Risks**:\n    - **리스크**: 거래 데이터 증가 시 대시보드 집계 쿼리 성능 저하로 인한 로딩 속도 지연.\n    - **Mitigation Strategies**: PRD에 명시된 대로 Materialized View를 선제적으로 도입하여 복잡한 집계 연산을 미리 계산해 둡니다. 쿼리 실행 계획을 분석하여 비효율적인 쿼리를 튜닝하고, 필요한 컬럼에 인덱스를 추가합니다.\n- **Security Risks**:\n    - **리스크**: 멤버 초대 과정에서 발생하는 인증 토큰 탈취 또는 오용 가능성.\n    - **Mitigation Strategies**: 초대 링크에 유효 시간이 짧은 일회성 토큰(JWT)을 사용합니다. 이메일 수신자 본인만 링크를 수락할 수 있도록 Google OAuth 인증을 거치게 하여 보안을 강화합니다.\n- **Integration Risks**:\n    - **리스크**: 토스페이먼츠 등 외부 결제 API의 장애 또는 정책 변경으로 인한 결제 기능 중단.\n    - **Mitigation Strategies**: 결제 처리 로직에 대한 예외 처리 및 재시도 메커니즘을 견고하게 구현합니다. 웹훅(Webhook) 요청 실패 시를 대비한 로깅 및 알림 시스템을 구축하여 신속하게 문제를 인지하고 대응할 수 있도록 합니다.\n\n### Project Delivery Risks\n- **Timeline Risks**:\n    - **리스크**: 8주라는 MVP 개발 일정이 매우 공격적이어서, 예상치 못한 기술적 난관 발생 시 지연 가능성이 높음.\n    - **Mitigation Strategies**: MVP 기능 범위를 철저히 관리하고, 'NICE TO HAVE' 기능의 우선순위를 조정할 수 있도록 유연성을 확보합니다. 2주 단위 스프린트 회고를 통해 지속적으로 진행 상황을 점검하고 병목 현상을 조기에 해결합니다.\n- **Resource Risks**:\n    - **리스크**: 개발팀이 Supabase RLS, Drizzle ORM 등 특정 기술 스택에 대한 경험이 부족할 경우 학습 곡선으로 인한 개발 속도 저하.\n    - **Mitigation Strategies**: 개발 시작 전, 핵심 기술에 대한 공식 문서 학습 및 PoC(Proof of Concept)를 진행하여 기술적 이해도를 높입니다. 복잡한 부분은 페어 프로그래밍을 통해 지식을 공유하고 리스크를 분산합니다.\n- **Quality Risks**:\n    - **리스크**: 빠른 개발 속도에 치중하여 단위 테스트 및 E2E 테스트 커버리지가 부족해져 런칭 후 버그 발생률 증가.\n    - **Mitigation Strategies**: 인증, 결제, 핵심 데이터 CRUD 등 크리티컬한 기능에 대해서는 반드시 테스트 코드를 작성하는 것을 원칙으로 합니다. 런칭 전 QA 기간을 별도로 확보하여 주요 사용자 시나리오에 대한 테스트를 집중적으로 수행합니다.\n- **Deployment Risks**:\n    - **리스크**: 개발 환경과 프로덕션 환경의 미세한 차이(환경 변수, RLS 정책 등)로 인해 배포 후 예상치 못한 오류 발생.\n    - **Mitigation Strategies**: Vercel의 Preview Deployment 기능을 적극 활용하여 PR(Pull Request)마다 실제 프로덕션과 유사한 환경에서 변경 사항을 사전 검증합니다. 환경 변수 관리를 위한 명확한 프로세스를 수립하고, Supabase 환경(dev, prod) 분리 전략을 고려합니다.",
      "writedAt": "2025-09-09T13:44:40.108Z"
    },
    {
      "type": "guideline",
      "content": "\n    # Senior Developer Guidelines\n    \n    ## Must\n    \n    - always use client component for all components. (use `use client` directive)\n    - always use promise for page.tsx params props.\n    - use valid picsum.photos stock image for placeholder image\n    \n    ## Library\n    \n    use following libraries for specific functionalities:\n    \n    1. `date-fns`: For efficient date and time handling.\n    2. `ts-pattern`: For clean and type-safe branching logic.\n    3. `@tanstack/react-query`: For server state management.\n    4. `zustand`: For lightweight global state management.\n    5. `react-use`: For commonly needed React hooks.\n    6. `es-toolkit`: For robust utility functions.\n    7. `lucide-react`: For customizable icons.\n    8. `zod`: For schema validation and data integrity.\n    9. `shadcn-ui`: For pre-built accessible UI components.\n    10. `tailwindcss`: For utility-first CSS styling.\n    11. `supabase`: For a backend-as-a-service solution.\n    12. `react-hook-form`: For form validation and state management.\n    \n    ## Directory Structure\n    \n    - src\n    - src/app: Next.js App Routers\n    - src/components/ui: shadcn-ui components\n    - src/constants: Common constants\n    - src/hooks: Common hooks\n    - src/lib: utility functions\n    - src/remote: http client\n    - src/features/[featureName]/components/*: Components for specific feature\n    - src/features/[featureName]/constants/*\n    - src/features/[featureName]/hooks/*\n    - src/features/[featureName]/lib/*\n    - src/features/[featureName]/api.ts: api fetch functions\n    \n    ## Solution Process:\n    \n    1. Rephrase Input: Transform to clear, professional prompt.\n    2. Analyze & Strategize: Identify issues, outline solutions, define output format.\n    3. Develop Solution:\n       - \"As a senior-level developer, I need to [rephrased prompt]. To accomplish this, I need to:\"\n       - List steps numerically.\n       - \"To resolve these steps, I need the following solutions:\"\n       - List solutions with bullet points.\n    4. Validate Solution: Review, refine, test against edge cases.\n    5. Evaluate Progress:\n       - If incomplete: Pause, inform user, await input.\n       - If satisfactory: Proceed to final output.\n    6. Prepare Final Output:\n       - ASCII title\n       - Problem summary and approach\n       - Step-by-step solution with relevant code snippets\n       - Format code changes:\n        ```language:path/to/file\n         // ... existing code ...\n         function exampleFunction() {\n             // Modified or new code here\n         }\n         // ... existing code ...\n         ```\n       - Use appropriate formatting\n       - Describe modifications\n       - Conclude with potential improvements\n    \n    ## Key Mindsets:\n    \n    1. Simplicity\n    2. Readability\n    3. Maintainability\n    4. Testability\n    5. Reusability\n    6. Functional Paradigm\n    7. Pragmatism\n    \n    ## Code Guidelines:\n    \n    1. Early Returns\n    2. Conditional Classes over ternary\n    3. Descriptive Names\n    4. Constants > Functions\n    5. DRY\n    6. Functional & Immutable\n    7. Minimal Changes\n    8. Pure Functions\n    9. Composition over inheritance\n    \n    ## Functional Programming:\n    \n    - Avoid Mutation\n    - Use Map, Filter, Reduce\n    - Currying and Partial Application\n    - Immutability\n    \n    ## Code-Style Guidelines\n    \n    - Use TypeScript for type safety.\n    - Follow the coding standards defined in the ESLint configuration.\n    - Ensure all components are responsive and accessible.\n    - Use Tailwind CSS for styling, adhering to the defined color palette.\n    - When generating code, prioritize TypeScript and React best practices.\n    - Ensure that any new components are reusable and follow the existing design patterns.\n    - Minimize the use of AI generated comments, instead use clearly named variables and functions.\n    - Always validate user inputs and handle errors gracefully.\n    - Use the existing components and pages as a reference for the new components and pages.\n    \n    ## Performance:\n    \n    - Avoid Premature Optimization\n    - Profile Before Optimizing\n    - Optimize Judiciously\n    - Document Optimizations\n    \n    ## Comments & Documentation:\n    \n    - Comment function purpose\n    - Use JSDoc for JS\n    - Document \"why\" not \"what\"\n    \n    ## Function Ordering:\n    \n    - Higher-order functionality first\n    - Group related functions\n    \n    ## Handling Bugs:\n    \n    - Use TODO: and FIXME: comments\n    \n    ## Error Handling:\n    \n    - Use appropriate techniques\n    - Prefer returning errors over exceptions\n    \n    ## Testing:\n    \n    - Unit tests for core functionality\n    - Consider integration and end-to-end tests\n    \n    ## Next.js\n    \n    - you must use promise for page.tsx params props.\n    \n    ## Shadcn-ui\n    \n    - if you need to add new component, please show me the installation instructions. I'll paste it into terminal.\n    - example\n      ```\n      $ npx shadcn@latest add card\n      $ npx shadcn@latest add textarea\n      $ npx shadcn@latest add dialog\n      ```\n    \n    ## Supabase\n    \n    - if you need to add new table, please create migration. I'll paste it into supabase.\n    - do not run supabase locally\n    - store migration query for `.sql` file. in /supabase/migrations/\n    \n    ## Package Manager\n    \n    - use npm as package manager.\n    \n    ## Korean Text\n    \n    - 코드를 생성한 후에 utf-8 기준으로 깨지는 한글이 있는지 확인해주세요. 만약 있다면 수정해주세요.\n    \n    You are a senior full-stack developer, one of those rare 10x devs. Your focus: clean, maintainable, high-quality code.\n    Apply these principles judiciously, considering project and team needs.\n      ",
      "writedAt": "2025-09-09T13:44:40.108Z"
    },
    {
      "type": "design-guide",
      "content": "# BuddyBudget Design Guide\n\n## 1. Overall Mood (전체적인 무드)\n\nBuddyBudget은 가족, 룸메이트, 커플이 함께 사용하는 공동 가계부 서비스로서 **친근하고 따뜻한** 무드를 추구합니다. 복잡한 금융 관리를 부담 없이 접근할 수 있도록 하며, 사용자들 간의 협업과 소통을 장려하는 친밀한 분위기를 조성합니다. \n\n전문적이면서도 접근하기 쉬운 디자인을 통해 초보자도 쉽게 사용할 수 있으면서, 숙련된 사용자에게는 효율적인 워크플로우를 제공합니다. 따뜻한 색상과 부드러운 형태를 사용하여 금융 관리라는 다소 딱딱할 수 있는 주제를 친근하게 만들어줍니다.\n\n## 2. Reference Service (참조 서비스)\n\n- **Name**: Splitwise\n- **Description**: 친구들과 룸메이트를 위한 공동 지출 관리 및 정산 앱\n- **Design Mood**: 깔끔하고 직관적이며 친근한 인터페이스로 복잡한 정산을 간단하게 만드는 디자인\n- **Primary Color**: #5BC5A7 (민트 그린)\n- **Secondary Color**: #FFFFFF (화이트)\n\n## 3. Color & Gradient (색상 & 그라데이션)\n\n- **Primary Color**: #FFB38A (따뜻한 살구색)\n- **Secondary Color**: #5ED5A8 (상쾌한 민트)\n- **Accent Color**: #FFE489 (밝은 노란색)\n- **Surface Color**: #FFF9F3 (아이보리)\n- **Text Color**: #25324A (부드러운 네이비)\n- **Gray Scale**: \n  - Gray 50: #F8FAFC\n  - Gray 100: #F1F5F9\n  - Gray 300: #CBD5E1\n  - Gray 500: #64748B\n  - Gray 700: #334155\n- **Mood**: 따뜻하고 중간 채도의 색상으로 친근함과 신뢰감을 동시에 전달\n- **Color Usage**: \n  - Primary: 주요 CTA 버튼, 그래프 하이라이트, 중요한 액션 요소\n  - Secondary: 보조 버튼, 성공 상태, 긍정적 피드백\n  - Accent: 알림, 배지, 주의 사항, 새로운 기능 강조\n  - Surface: 카드 배경, 모달 배경\n  - Text: 모든 텍스트 요소에서 WCAG AA 기준 4.5:1 대비율 확보\n\n## 4. Typography & Font (타이포그래피 & 폰트)\n\n- **Font Family**: Pretendard (한국어 최적화 폰트)\n- **Heading 1**: Pretendard SemiBold, 32px, Letter-spacing: -0.02em\n- **Heading 2**: Pretendard SemiBold, 24px, Letter-spacing: -0.01em\n- **Heading 3**: Pretendard SemiBold, 20px, Letter-spacing: -0.01em\n- **Body Large**: Pretendard Regular, 16px, Line-height: 1.5\n- **Body**: Pretendard Regular, 14px, Line-height: 1.5\n- **Caption**: Pretendard Light, 12px, Line-height: 1.4\n- **Button Text**: Pretendard Medium, 14px\n- **Font Scale**: 12/14/16/20/24/32px (Tailwind utility 기반)\n\n## 5. Layout & Structure (레이아웃 & 구조)\n\n**Grid System**: \n- 12컬럼 그리드 시스템 사용\n- Container max-width: 1280px\n- Gutter: 24px (desktop), 16px (mobile)\n\n**Spacing System**:\n- 4px 기준 spacing scale (4, 8, 12, 16, 24, 32, 48, 64px)\n- 카드 간격: 24px\n- 섹션 간격: 48px\n\n**Responsive Breakpoints**:\n- Mobile: ≥ 375px\n- Tablet: ≥ 768px  \n- Desktop: ≥ 1024px\n- Large Desktop: ≥ 1280px\n\n**Navigation Structure**:\n- Desktop: 고정 사이드바 (240px width)\n- Mobile: 하단 탭 네비게이션 + 햄버거 드로어\n\n## 6. Visual Style (비주얼 스타일)\n\n**아이콘**:\n- Library: lucide-react\n- Style: 1.5px stroke weight, rounded caps and joins\n- 기본 색상: Soft Navy (#25324A)\n- 강조 시: Primary color fill\n\n**일러스트레이션**:\n- 플랫 디자인 스타일\n- 파스텔 톤의 미니멀한 캐릭터 (집, 동전 모티프)\n- 배경 일러스트는 마케팅 페이지에만 제한적 사용\n\n**이미지 처리**:\n- Border radius: 8px (기본), 16px (카드)\n- 그림자: shadow-sm (기본), shadow-md (호버)\n\n**애니메이션**:\n- Duration: 200-300ms\n- Easing: ease-out\n- 페이지 전환: Fade + Slide-up 8px\n- 성공 액션 후: Confetti 효과 (Mint + Apricot, 1초)\n\n## 7. UX Guide (UX 가이드)\n\n**초보자를 위한 UX**:\n- 첫 로그인 후 3단계 온보딩 튜토리얼\n- 빠른 거래 입력 위젯에 예시 플레이스홀더 제공\n- 예산 설정 페이지에 도움말 툴팁 제공\n- 도움말 센터 링크 및 '시작하기 투어' 버튼\n- 에러 메시지는 해결 방법과 함께 친근한 톤으로 제공\n\n**숙련자를 위한 UX**:\n- 대시보드에 핵심 KPI 카드 집중 배치\n- 키보드 단축키: 'T' (거래 입력), '/' (글로벌 검색)\n- 빠른 액션을 위한 QuickAdd 위젯\n- 고급 필터링 및 검색 기능\n\n**공통 UX 원칙**:\n- 3분 이내 첫 가치 체험 (TTV)\n- 30초 이내 거래 입력 완료\n- 실시간 피드백 및 상태 표시\n- 명확한 정보 계층 구조\n\n## 8. UI Component Guide (UI 컴포넌트 가이드)\n\n**버튼**:\n- Primary: Background #FFB38A, Text White, Border radius 8px, Padding 12px 24px\n- Secondary: Border #5ED5A8, Text #5ED5A8, Background transparent\n- Destructive: Background #EF4444, Text White\n- 호버 시: 10% 어둡게, transform scale(1.02)\n\n**입력 필드**:\n- Border: 1px solid #CBD5E1\n- Focus: Border #FFB38A, Box-shadow 0 0 0 3px rgba(255, 179, 138, 0.1)\n- Border radius: 8px\n- Padding: 12px 16px\n- Placeholder: #64748B\n\n**카드**:\n- Background: #FFF9F3 (Surface color)\n- Border radius: 12px\n- Shadow: 0 1px 3px rgba(0, 0, 0, 0.1)\n- Padding: 24px\n- 호버 시: Shadow 증가\n\n**사이드바** (Desktop):\n- Width: 240px\n- Collapsible 기능\n- Background: White\n- 메뉴 항목: Dashboard, 거래내역, 계좌관리, 카테고리, 예산, 설정\n\n**하단 네비게이션** (Mobile):\n- 고정 하단 탭: Dashboard, 거래내역, QuickAdd, 계좌관리, 설정\n- Height: 64px\n- 활성 탭: Primary color 강조\n\n**모달**:\n- Backdrop: rgba(0, 0, 0, 0.5)\n- Content: White background, border radius 16px\n- 최대 width: 500px\n- 애니메이션: Scale + Fade\n\n**토스트 알림**:\n- 성공: Secondary color 배경\n- 경고: Accent color 배경  \n- 오류: Red 배경\n- 위치: 화면 우상단\n- Duration: 4초\n\n**다크 모드**:\n- Primary: #E59A73\n- Secondary: #4CB894\n- Surface: #1E1E1E\n- Text: #F3F5F7\n- 토글 위치: 설정 페이지 상단\n\n**접근성 고려사항**:\n- 모든 색상 조합에서 WCAG 2.1 AA 기준 대비율 확보\n- 모든 인터랙티브 요소에 Focus 스타일 적용\n- 폼 라벨과 aria-label 완전 지원\n- 키보드 네비게이션 지원",
      "writedAt": "2025-09-09T13:44:40.108Z"
    },
    {
      "type": "ia",
      "content": "# BuddyBudget Information Architecture (IA)\n\n## 1. 사이트맵\n\n```\n/ (홈페이지)\n├── /auth\n│   ├── /auth/signin (로그인)\n│   └── /auth/signup (회원가입)\n├── /[slug] (스페이스 대시보드)\n│   ├── /[slug]/transactions (거래 내역)\n│   │   ├── /[slug]/transactions/new (새 거래 등록)\n│   │   └── /[slug]/transactions/[id]/edit (거래 수정)\n│   ├── /[slug]/accounts (계정 관리)\n│   │   ├── /[slug]/accounts/new (새 계정 등록)\n│   │   └── /[slug]/accounts/[id]/edit (계정 수정)\n│   ├── /[slug]/categories (카테고리 관리)\n│   │   ├── /[slug]/categories/new (새 카테고리 등록)\n│   │   └── /[slug]/categories/[id]/edit (카테고리 수정)\n│   ├── /[slug]/budgets (예산 관리)\n│   │   └── /[slug]/budgets/setup (예산 설정)\n│   └── /[slug]/settings (스페이스 설정)\n│       ├── /[slug]/settings/general (일반 설정)\n│       ├── /[slug]/settings/members (멤버 관리)\n│       ├── /[slug]/settings/billing (결제 및 플랜)\n│       ├── /[slug]/settings/notifications (알림 설정)\n│       └── /[slug]/settings/appearance (화면 설정)\n├── /create-space (새 스페이스 생성)\n├── /accept-invite/[token] (초대 수락)\n└── /help (도움말 센터)\n```\n\n## 2. 사용자 흐름\n\n### 주요 작업: 신규 사용자 온보딩\n1. 사용자가 홈페이지에서 '시작하기' 버튼 클릭\n2. Google OAuth 로그인 페이지로 이동\n3. 로그인 완료 후 '새 스페이스 생성' 모달 표시\n4. 스페이스 이름 입력 (예: \"신림 3인하우스\")\n5. 스페이스 대시보드로 리다이렉트\n6. 3단계 온보딩 튜토리얼 진행:\n   - 1단계: 첫 거래 입력 (빠른 입력 위젯 사용)\n   - 2단계: 월 예산 설정\n   - 3단계: 룸메이트 초대\n7. 대시보드에서 실시간 잔액 및 집행률 확인\n\n### 주요 작업: 멤버 초대 및 참여\n1. 스페이스 소유자가 설정 > 멤버 관리 페이지 접근\n2. '멤버 초대' 버튼 클릭\n3. 초대할 사람의 이메일 주소 입력\n4. 초대 이메일 발송\n5. 피초대자가 이메일의 초대 링크 클릭\n6. Google 로그인 (신규 가입자의 경우 자동 회원가입)\n7. 스페이스 참여 확인 페이지\n8. '참여하기' 버튼 클릭\n9. 스페이스 대시보드로 이동하여 활동 시작\n\n### 주요 작업: 빠른 거래 입력\n1. 대시보드 상단의 빠른 입력 위젯 클릭\n2. 거래 유형 선택 (지출/수입/이체)\n3. 금액 입력 (숫자 키패드 UI)\n4. 카테고리 선택 (자주 사용하는 항목 우선 표시)\n5. 계정 선택 (현금/카드/은행계좌)\n6. 메모 입력 (선택사항)\n7. '저장' 버튼 클릭\n8. 성공 토스트 알림 표시\n9. 대시보드 잔액 및 집행률 실시간 업데이트\n\n## 3. 네비게이션 구조\n\n### 데스크톱 - 고정 사이드바 (240px)\n- **주요 메뉴**\n  - 대시보드 (홈 아이콘)\n  - 거래내역 (리스트 아이콘)\n  - 계정관리 (지갑 아이콘)\n  - 카테고리 (태그 아이콘)\n  - 예산관리 (파이차트 아이콘)\n- **하단 메뉴**\n  - 설정 (톱니바퀴 아이콘)\n  - 도움말 (물음표 아이콘)\n  - 다크모드 토글\n\n### 모바일 - 하단 탭 네비게이션 (64px)\n- 대시보드\n- 거래내역\n- 빠른입력 (+ 아이콘, 중앙 강조)\n- 계정관리\n- 설정\n\n### 글로벌 네비게이션 바 (상단)\n- 스페이스 선택 드롭다운 (현재 스페이스명 표시)\n- 전역 검색 (키보드 단축키: '/')\n- 알림 벨 아이콘\n- 사용자 프로필 드롭다운\n\n## 4. 페이지 계층 구조\n\n```\n/ (Depth 1)\n├── /auth (Depth 1)\n│   ├── /auth/signin (Depth 2)\n│   └── /auth/signup (Depth 2)\n├── /[slug] (Depth 1)\n│   ├── /[slug]/transactions (Depth 2)\n│   │   ├── /[slug]/transactions/new (Depth 3)\n│   │   └── /[slug]/transactions/[id]/edit (Depth 3)\n│   ├── /[slug]/accounts (Depth 2)\n│   │   ├── /[slug]/accounts/new (Depth 3)\n│   │   └── /[slug]/accounts/[id]/edit (Depth 3)\n│   ├── /[slug]/categories (Depth 2)\n│   │   ├── /[slug]/categories/new (Depth 3)\n│   │   └── /[slug]/categories/[id]/edit (Depth 3)\n│   ├── /[slug]/budgets (Depth 2)\n│   │   └── /[slug]/budgets/setup (Depth 3)\n│   └── /[slug]/settings (Depth 2)\n│       ├── /[slug]/settings/general (Depth 3)\n│       ├── /[slug]/settings/members (Depth 3)\n│       ├── /[slug]/settings/billing (Depth 3)\n│       ├── /[slug]/settings/notifications (Depth 3)\n│       └── /[slug]/settings/appearance (Depth 3)\n├── /create-space (Depth 1)\n├── /accept-invite/[token] (Depth 1)\n└── /help (Depth 1)\n```\n\n## 5. 콘텐츠 구성\n\n| 페이지 | 주요 콘텐츠 요소 |\n|---|---|\n| 홈페이지 | 히어로 섹션, 주요 기능 소개, CTA 버튼, 가격 정보 |\n| 대시보드 | 잔액 카드, 집행률 프로그레스 바, 최근 거래 목록, 빠른 입력 위젯, 예산 현황 차트 |\n| 거래내역 | 필터 및 검색 바, 거래 목록 테이블, 페이지네이션, 새 거래 등록 버튼 |\n| 거래 입력/수정 | 거래 유형 선택, 금액 입력 필드, 카테고리 드롭다운, 계정 선택, 메모 입력, 날짜 선택기 |\n| 계정관리 | 계정 목록 카드, 각 계정별 잔액 표시, 새 계정 추가 버튼, 계정 편집/삭제 액션 |\n| 카테고리 관리 | 카테고리 목록, 색상 표시, 사용 빈도 통계, 새 카테고리 추가 버튼 |\n| 예산관리 | 카테고리별 예산 설정 폼, 집행률 차트, 예산 초과 알림 설정 |\n| 멤버 관리 | 현재 멤버 목록, 권한 표시, 초대 링크 생성, 멤버 제거 기능 |\n| 설정 | 탭 메뉴, 각종 설정 폼, 다크모드 토글, 알림 설정 체크박스 |\n\n## 6. 인터랙션 패턴\n\n### 모달 사용 패턴\n- **빠른 거래 입력**: 대시보드에서 즉시 접근 가능한 모달\n- **확인 대화상자**: 삭제, 초대 취소 등 중요한 액션 전 확인\n- **업그레이드 안내**: 무료 플랜 한도 초과 시 유료 플랜 안내 모달\n\n### 토스트 알림 패턴\n- **성공 액션**: 거래 저장, 멤버 초대 완료 등 (민트 색상)\n- **경고**: 예산 초과 위험 (노란색)\n- **오류**: 네트워크 오류, 유효성 검사 실패 (빨간색)\n\n### 무한 스크롤 패턴\n- 거래내역 목록에서 오래된 거래 로딩 시 사용\n\n### 툴팁 패턴\n- 예산 설정 페이지의 도움말 아이콘\n- 대시보드 차트의 상세 정보 표시\n\n### 드래그 앤 드롭 패턴\n- 카테고리 순서 변경\n- 계정 우선순위 조정\n\n## 7. URL 구조\n\n### 일반 원칙\n- **리소스명**: 복수형 사용 (`/transactions`, `/accounts`)\n- **상세 페이지**: `/resource-name/:id`\n- **액션 페이지**: `/resource-name/action` (예: `/transactions/new`)\n- **스페이스 기반**: 모든 주요 기능은 `/[slug]` 하위에 위치\n\n### URL 예시\n```\n/ (마케팅 홈페이지)\n/auth/signin\n/create-space\n/my-family-budget (스페이스 대시보드)\n/my-family-budget/transactions\n/my-family-budget/transactions/new\n/my-family-budget/transactions/123/edit\n/my-family-budget/accounts\n/my-family-budget/budgets/setup\n/my-family-budget/settings/members\n/accept-invite/abc123token\n```\n\n## 8. 컴포넌트 계층 구조\n\n### 글로벌 컴포넌트\n- **Header**: 스페이스 선택, 검색, 알림, 사용자 메뉴\n- **Sidebar**: 데스크톱 네비게이션 메뉴\n- **BottomNav**: 모바일 하단 탭 네비게이션\n- **Footer**: 마케팅 페이지에서만 사용\n- **Toast**: 전역 알림 시스템\n- **Modal**: 기본 모달 컨테이너\n\n### 레이아웃 컴포넌트\n- **DashboardLayout**: 사이드바 + 메인 콘텐츠 영역\n- **AuthLayout**: 인증 페이지용 중앙 정렬 레이아웃\n- **SettingsLayout**: 설정 페이지용 탭 레이아웃\n\n### 카드 컴포넌트\n- **BalanceCard**: 잔액 표시 카드\n- **BudgetCard**: 예산 집행률 카드\n- **TransactionCard**: 거래 내역 카드\n- **AccountCard**: 계정 정보 카드\n- **MemberCard**: 멤버 정보 카드\n\n### 폼 컴포넌트\n- **TransactionForm**: 거래 입력/수정 폼\n- **BudgetForm**: 예산 설정 폼\n- **InviteForm**: 멤버 초대 폼\n- **AccountForm**: 계정 생성/수정 폼\n\n### 데이터 표시 컴포넌트\n- **TransactionList**: 거래 목록 테이블\n- **BudgetChart**: 예산 현황 차트\n- **BalanceChart**: 잔액 변화 그래프\n- **CategoryPieChart**: 카테고리별 지출 파이 차트\n\n### 입력 컴포넌트\n- **QuickAddWidget**: 빠른 거래 입력 위젯\n- **AmountInput**: 금액 입력 필드 (천 단위 콤마 자동 적용)\n- **CategorySelect**: 카테고리 선택 드롭다운\n- **AccountSelect**: 계정 선택 드롭다운\n- **DatePicker**: 날짜 선택기\n\n### 피드백 컴포넌트\n- **LoadingSpinner**: 로딩 표시기\n- **EmptyState**: 빈 상태 일러스트레이션\n- **ErrorBoundary**: 오류 경계 컴포넌트\n- **ConfirmDialog**: 확인 대화상자\n\n### 유틸리티 컴포넌트\n- **Badge**: 상태 표시 배지\n- **ProgressBar**: 진행률 표시 바\n- **Avatar**: 사용자 프로필 이미지\n- **Tooltip**: 도움말 툴팁\n- **SearchInput**: 전역 검색 입력 필드",
      "writedAt": "2025-09-09T13:44:40.108Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-09-09T13:44:40.108Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-09-09T13:44:40.108Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-09-09T13:44:40.108Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-09-09T13:44:40.108Z"
    },
    {
      "type": "isms-p",
      "content": "\n# ISMS-P Based Secure Development Rules (v1.0)\n# This document defines the mandatory security rules for developers during code implementation.\n# Reference: Based on the Information Security Management System - Personal Information (ISMS-P) standard.\n\n## 1. Authentication & Authorization\n- **(A-1) User Identification and Authentication**\n  - **MUST**: Every user must be individually identifiable. The use of shared accounts is prohibited.\n  - **MUST**: Passwords MUST satisfy one of the following policies:\n    - (a) 8+ characters with a mix of letters, numbers, and special characters.\n    - (b) 10+ characters with a mix of letters and numbers.\n  - **MUST**: An account lockout policy MUST be implemented for failed login attempts (e.g., lock the account for 5 minutes after 5 consecutive failures).\n\n- **(A-2) Management of Authentication Credentials**\n  - **MUST**: Authentication credentials such as passwords MUST be stored using an adaptive hash function like **bcrypt, scrypt, or Argon2**. (Using SHA-256 alone is prohibited).\n\n- **(A-3) Privilege Management**\n  - **MUST**: Grant only the minimum necessary privileges for a role, following the **Principle of Least Privilege**.\n  - **MUST**: All actions of granting, changing, and revoking privileges MUST be logged.\n\n- **(A-4) Privileged Access Management**\n  - **MUST**: Administrative privileges (e.g., root, admin) MUST be granted to a minimum number of users, and the reason for using such accounts MUST be clearly logged.\n  - **SHOULD**: Administrative accounts SHOULD be separate from regular user accounts.\n\n## 2. Access Control\n- **(AC-1) System Access**\n  - **MUST**: Access to information systems by unauthorized users MUST be blocked.\n  - **MUST**: Access logs for critical systems MUST be retained for **at least one year**.\n\n- **(AC-2) Network Access**\n  - **MUST**: Public-facing services MUST be located in a **DMZ**, separate from the internal network.\n  - **MUST**: Firewalls MUST allow only the minimum necessary ports required for the service. (Prohibit \"allow all\" rules).\n\n## 3. Cryptography\n- **(C-1) Encryption of Sensitive Information**\n  - **MUST**: Legally defined sensitive information (e.g., national ID numbers, passport numbers, bank account numbers, credit card numbers) and passwords MUST be encrypted during storage and transmission.\n  - **MUST**: Use secure and vetted cryptographic algorithms such as **AES-256**.\n  - **MUST NOT**: Do not use homegrown or custom-developed cryptographic algorithms.\n\n- **(C-2) Cryptographic Key Management**\n  - **MUST NOT**: Do not hardcode cryptographic keys in source code, configuration files, or comments.\n  - **MUST**: Cryptographic keys MUST be managed securely using **environment variables** or a dedicated **Key Management System (KMS, HSM)**.\n  - **MUST**: Minimize access to keys and log all lifecycle management procedures, including generation, use, and destruction.\n\n## 4. Secure Development\n- **(D-1) Secure Design**\n  - **MUST**: Defense mechanisms against major vulnerabilities like the **OWASP Top 10** (e.g., SQL Injection, XSS, CSRF) MUST be incorporated during the design phase.\n\n- **(D-2) Secure Coding**\n  - **MUST**: Treat all external input (e.g., request parameters, headers, cookies) as untrusted. **Validation and sanitization** logic MUST always be applied.\n  - **MUST**: All SQL queries MUST use **parameterized queries (prepared statements)**. (Dynamic query string concatenation is prohibited).\n  - **MUST**: When handling errors, ensure that internal system details (e.g., stack traces, database information) are not exposed to the user.\n\n- **(D-3) Security Testing**\n  - **SHOULD**: Periodically scan for security vulnerabilities using static/dynamic analysis tools (**SAST/DAST**).\n\n## 5. Personal Information Handling\n- **(P-1) Collection and Use**\n  - **MUST**: Collect only the minimum personal information necessary to provide the service. The purpose of collection MUST be clearly disclosed to users, and consent must be obtained.\n  - **MUST NOT**: Do not process sensitive information (e.g., beliefs, ideology) or unique identification information without a legal basis or separate user consent.\n\n- **(P-2) Storage and Display**\n  - **MUST**: Personal information MUST be **masked** when displayed on screen (e.g., John D**, +1-***-***-1234, test@****.com).\n  - **MUST NOT**: Do not use personal information or provide it to third parties beyond the scope of the consented purpose.\n\n- **(P-3) Destruction**\n  - **MUST**: When the retention period expires or the processing purpose is achieved, personal information MUST be completely destroyed using an irreversible method.\n  - **MUST**: Establish a personal information destruction procedure and maintain a log of all destructions.\n\n## 6. Logging & Management\n- **(L-1) Log Recording**\n  - **MUST**: Logs for critical activities (e.g., login, access to personal information, privilege changes) MUST be securely retained for **at least one year**.\n  - **MUST**: Logs MUST be standardized and include at least the following: [Timestamp, User ID, Source IP Address, Request/Action, Success/Failure Status].\n",
      "writedAt": "2025-09-09T13:44:40.108Z"
    }
  ]
}
